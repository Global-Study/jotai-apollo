{
  "version": 3,
  "sources": ["../src/clientAtom.ts", "../src/atomWithQuery.ts", "../src/common.ts", "../src/atomWithObservable.ts", "../src/storeVersionAtom.ts", "../src/atomWithMutation.ts", "../src/atomOfFragment.ts"],
  "sourcesContent": ["import { atom } from 'jotai'\nimport { ApolloClient } from '@apollo/client'\n\nlet client: ApolloClient<unknown> | null = null\nlet resolveClient: (client: ApolloClient<unknown>) => void\nconst clientPromise = new Promise<ApolloClient<unknown>>((resolve) => {\n  resolveClient = resolve\n})\n\nexport function initJotaiApollo(newClient: ApolloClient<unknown>) {\n  if (client !== null && client !== newClient) {\n    throw new Error(`Can setup jotai-apollo only once`)\n  }\n\n  client = newClient\n  resolveClient(client)\n}\n\nexport const clientAtom = atom(\n  async () => clientPromise,\n  (_get, _set, client: ApolloClient<unknown>) => {\n    initJotaiApollo(client)\n  }\n)\n", "import {\n  ApolloClient,\n  OperationVariables,\n  ApolloQueryResult,\n  ObservableQuery,\n  ApolloError,\n  NetworkStatus,\n  WatchQueryOptions,\n} from '@apollo/client'\nimport { atom, Getter, WritableAtom } from 'jotai'\n\nimport { clientAtom } from './clientAtom'\nimport { atomWithIncrement } from './common'\nimport { atomWithObservable } from './atomWithObservable'\nimport storeVersionAtom from './storeVersionAtom'\nimport { Observer } from './types'\n\ntype QueryArgs<\n  Variables extends object = OperationVariables,\n  Data = any\n> = WatchQueryOptions<Variables, Data>\n\ntype AtomWithQueryAction = {\n  type: 'refetch'\n}\n\nexport const atomWithQuery = <\n  Data,\n  Variables extends object = OperationVariables\n>(\n  getArgs: (get: Getter) => QueryArgs<Variables, Data>,\n  onError?: (result: ApolloQueryResult<Data | undefined>) => void,\n  getClient: (get: Getter) => Promise<ApolloClient<unknown>> = (get) =>\n    get(clientAtom)\n): WritableAtom<\n  Promise<ApolloQueryResult<Data | undefined>>,\n  [AtomWithQueryAction],\n  void\n> => {\n  const refreshAtom = atomWithIncrement(0)\n\n  const handleActionAtom = atom(\n    null,\n    (_get, set, action: AtomWithQueryAction) => {\n      if (action.type === 'refetch') {\n        set(refreshAtom)\n      }\n    }\n  )\n\n  const wrapperAtom = atom(async (get) => {\n    const client = await getClient(get)\n\n    const sourceAtom = atomWithObservable((get) => {\n      const args = getArgs(get)\n\n      // Resetting on store-version change\n      get(storeVersionAtom(client))\n      get(refreshAtom)\n\n      return wrapObservable(client.watchQuery(args))\n    })\n\n    return sourceAtom\n  })\n\n  return atom(\n    async (get) => {\n      const sourceAtom = await get(wrapperAtom)\n      const result = await get(sourceAtom)\n\n      if (result.error) {\n        if (onError) {\n          onError(result)\n        } else {\n          throw result.error\n        }\n      }\n\n      return result\n    },\n    (_get, set, action: AtomWithQueryAction) => set(handleActionAtom, action)\n  )\n}\n\ntype Subscription = {\n  unsubscribe: () => void\n}\n\nconst wrapObservable = <\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables\n>(\n  observableQuery: ObservableQuery<TData, TVariables>\n) => ({\n  subscribe: (\n    observer: Partial<Observer<ApolloQueryResult<TData | undefined>>>\n  ): Subscription => {\n    let subscription = observableQuery.subscribe(onNext, onError)\n\n    function onNext(result: ApolloQueryResult<TData>) {\n      observer.next?.(result)\n    }\n\n    function onError(error: unknown) {\n      const last = observableQuery['last']\n      subscription.unsubscribe()\n\n      try {\n        observableQuery.resetLastResults()\n        subscription = observableQuery.subscribe(onNext, onError)\n      } finally {\n        observableQuery['last'] = last\n      }\n\n      const errorResult: ApolloQueryResult<TData | undefined> = {\n        data: observableQuery.getCurrentResult().data,\n        error: error as ApolloError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      }\n\n      // Errors are returned as part of the result\n      observer.next?.(errorResult)\n    }\n\n    return {\n      unsubscribe: () => subscription.unsubscribe(),\n    }\n  },\n})\n", "import { atom } from 'jotai'\nimport type { Getter } from 'jotai'\nimport { atomWithObservable } from 'jotai/utils'\nimport { ApolloClient, ApolloQueryResult } from '@apollo/client'\n\ntype Client<T extends unknown = unknown> = ApolloClient<T>\n\nexport type Observer<T> = {\n  next: (value: T) => void\n  error: (error: any) => void\n  complete: () => void\n}\n\nexport type Observable<T> = {\n  subscribe(observer: Partial<Observer<T>>): { unsubscribe: () => void }\n}\n\nexport const atomWithIncrement = (initialValue: number) => {\n  const internalAtom = atom(initialValue)\n\n  return atom(\n    (get) => get(internalAtom),\n    (_get, set) => set(internalAtom, (c) => c + 1)\n  )\n}\n\nexport const createAtoms = <\n  Args,\n  Data,\n  Source extends Observable<ApolloQueryResult<Data>>,\n  Action,\n  ActionResult extends Promise<void> | void = void\n>(\n  getArgs: (get: Getter) => Args,\n  getClient: (get: Getter) => Client,\n  execute: (client: Client, args: Args) => Source,\n  handleAction: (\n    action: Action,\n    client: Client,\n    refresh: () => void\n  ) => ActionResult\n) => {\n  const refreshAtom = atomWithIncrement(0)\n\n  const handleActionAtom = atom(null, (get, set, action: Action) => {\n    const client = getClient(get)\n    const refresh = () => set(refreshAtom)\n\n    return handleAction(action, client, refresh)\n  })\n\n  const sourceAtom = atomWithObservable(\n    (get) => {\n      get(refreshAtom)\n      const args = getArgs(get)\n      const client = getClient(get)\n\n      return execute(client, args)\n    },\n    { initialValue: null }\n  )\n\n  const statusAtom = atom(\n    (get) => get(sourceAtom),\n    (_get, set, action: Action) => set(handleActionAtom, action)\n  )\n\n  const dataAtom = atom(\n    (get) => {\n      const result = get(sourceAtom)\n\n      if (result === null) {\n        return undefined\n      }\n\n      if (result.error) {\n        throw result.error\n      }\n      return result.data\n    },\n    (_get, set, action: Action) => set(handleActionAtom, action)\n  )\n\n  return [dataAtom, statusAtom] as const\n}\n", "import { Atom, Getter, WritableAtom, atom } from 'jotai'\n\ntype AnyError = unknown\n\ndeclare global {\n  interface SymbolConstructor {\n    readonly observable: symbol\n  }\n}\n\ntype Subscription = {\n  unsubscribe: () => void\n}\n\ntype Observer<T> = {\n  next: (value: T) => void\n  error: (error: AnyError) => void\n  complete: () => void\n}\n\ntype ObservableLike<T> = {\n  [Symbol.observable]?: () => ObservableLike<T> | undefined\n} & (\n  | {\n      subscribe(observer: Observer<T>): Subscription\n    }\n  | {\n      subscribe(observer: Partial<Observer<T>>): Subscription\n    }\n  | {\n      subscribe(observer: Partial<Observer<T>>): Subscription\n      // Overload function to make typing happy\n      subscribe(next: (value: T) => void): Subscription\n    }\n)\n\ntype SubjectLike<T> = ObservableLike<T> & Observer<T>\n\ntype Options<Data> = {\n  initialValue?: Data | (() => Data)\n}\n\ntype OptionsWithInitialValue<Data> = {\n  initialValue: Data | (() => Data)\n}\n\ntype LOADING = typeof LOADING\nconst LOADING = Symbol('atomWithObservable is in loading state')\n\nexport function atomWithObservable<Data>(\n  getObservable: (get: Getter) => SubjectLike<Data>,\n  options: OptionsWithInitialValue<Data>\n): WritableAtom<Data, [Data], void>\n\nexport function atomWithObservable<Data>(\n  getObservable: (get: Getter) => SubjectLike<Data>,\n  options?: Options<Data>\n): WritableAtom<Data | Promise<Data>, [Data], void>\n\nexport function atomWithObservable<Data>(\n  getObservable: (get: Getter) => ObservableLike<Data>,\n  options: OptionsWithInitialValue<Data>\n): Atom<Data>\n\nexport function atomWithObservable<Data>(\n  getObservable: (get: Getter) => ObservableLike<Data>,\n  options?: Options<Data>\n): Atom<Data | Promise<Data>>\n\nexport function atomWithObservable<Data>(\n  getObservable: (get: Getter) => ObservableLike<Data> | SubjectLike<Data>,\n  options?: Options<Data>\n) {\n  type Result = { d: Data } | { e: AnyError }\n  const returnResultData = (result: Result) => {\n    if ('e' in result) {\n      throw result.e\n    }\n    return result.d\n  }\n\n  const observableResultAtom = atom((get) => {\n    let observable = getObservable(get)\n    const itself = observable[Symbol.observable]?.()\n    if (itself) {\n      observable = itself\n    }\n\n    const STATE: {\n      pending: Promise<Result> | undefined\n      resolve: ((result: Result) => void) | undefined\n      subscription: Subscription | undefined\n      syncResult: Result | LOADING\n      updateResult: ((res: Result) => void) | undefined\n    } = {\n      pending: undefined,\n      resolve: undefined,\n      subscription: undefined,\n      syncResult: LOADING,\n      updateResult: undefined,\n    }\n\n    const initialResult: Result | LOADING =\n      options && 'initialValue' in options\n        ? {\n            d:\n              typeof options.initialValue === 'function'\n                ? (options.initialValue as () => Data)()\n                : (options.initialValue as Data),\n          }\n        : LOADING\n\n    const latestAtom = atom<Result | LOADING>(initialResult)\n\n    const resultAtom = atom<Result | Promise<Result>, [Result], void>(\n      (get, { setSelf }) => {\n        // Both getting the data, and depending on it, since we exit early in sync mode.\n        // TLDR, order matters\n        const latestData = get(latestAtom)\n\n        const updateResult = (res: Result) => {\n          if (!STATE.pending) {\n            // In case the subscription sets its value immediately.\n            // We want to avoid calling `setSelf` synchronously.\n            STATE.syncResult = res\n            setTimeout(() => setSelf(res), 0)\n          } else {\n            setSelf(res)\n          }\n        }\n\n        if (!STATE.pending) {\n          STATE.pending = new Promise((resolve: (result: Result) => void) => {\n            STATE.resolve = resolve\n\n            STATE.subscription = observable.subscribe({\n              next: (d) => updateResult({ d }),\n              error: (e) => updateResult({ e }),\n              complete: () => {},\n            })\n          })\n        }\n\n        if (STATE.syncResult !== LOADING) {\n          return STATE.syncResult\n        }\n\n        if (latestData !== LOADING) {\n          return latestData\n        }\n\n        return STATE.pending\n      },\n      (_get, set, result) => {\n        if (STATE.resolve === undefined) {\n          console.warn(\n            `atomWithObservable is in an invalid state, 'resolve' is undefined`\n          )\n          return\n        }\n\n        STATE.syncResult = LOADING // resetting the sync result\n        STATE.resolve(result)\n        set(latestAtom, result)\n      }\n    )\n\n    return [resultAtom, observable] as const\n  })\n\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom)\n      const result = get(resultAtom)\n      if (result instanceof Promise) {\n        return result.then(returnResultData)\n      }\n      return returnResultData(result)\n    },\n    (get, _set, data: Data) => {\n      const [_resultAtom, observable] = get(observableResultAtom)\n\n      if ('next' in observable) {\n        observable.next(data)\n      } else {\n        throw new Error('observable is not subject')\n      }\n    }\n  )\n\n  return observableAtom\n}\n", "import { atomFamily } from 'jotai/utils'\nimport { ApolloClient } from '@apollo/client'\n\nimport { atomWithObservable } from './atomWithObservable'\nimport type { Observer } from './types'\n\n/**\n * Gets incremented when the Apollo client clears the store.\n */\nconst storeVersionAtom = atomFamily((client: ApolloClient<unknown>) => {\n  return atomWithObservable(\n    () => {\n      let version = 0\n\n      return {\n        subscribe(observer: Observer<number>) {\n          return {\n            unsubscribe: client.onClearStore(async () => {\n              observer.next(++version)\n            }),\n          }\n        },\n      }\n    },\n    { initialValue: 0 }\n  )\n})\n\nexport default storeVersionAtom\n", "import {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  MutationOptions,\n  OperationVariables,\n} from '@apollo/client'\nimport { Getter, atom } from 'jotai'\n\nimport { clientAtom } from './clientAtom'\n\nexport const atomWithMutation = <\n  Data,\n  Variables extends OperationVariables,\n  Context extends Record<string, any> = DefaultContext\n>(\n  mutation: DocumentNode,\n  onError?: (error: unknown) => void,\n  getClient: (get: Getter) => Promise<ApolloClient<unknown>> = (get) =>\n    get(clientAtom)\n) => {\n  return atom(\n    null,\n    async (\n      get,\n      _set,\n      options: Omit<MutationOptions<Data, Variables, Context>, 'mutation'>\n    ) => {\n      const client = await getClient(get)\n\n      try {\n        return client.mutate({\n          ...options,\n          mutation: mutation as any,\n        })\n      } catch (e) {\n        if (onError) {\n          onError(e)\n          return { data: undefined, errors: e }\n        }\n\n        throw e\n      }\n    }\n  )\n}\n", "import { loadable } from 'jotai/utils'\nimport { Atom, atom, Getter } from 'jotai'\nimport { DocumentNode, DataProxy, StoreObject } from '@apollo/client'\nimport { getFragmentQueryDocument } from '@apollo/client/utilities/graphql/fragments'\n\nimport { clientAtom } from './clientAtom'\nimport { atomWithObservable } from './atomWithObservable'\nimport storeVersionAtom from './storeVersionAtom'\nimport { Observer } from './types'\n\ntype WatchFragmentArgs<Data = any> = {\n  fragment: DocumentNode\n  fragmentName: string\n  from: Partial<Data> | string | undefined\n  optimistic: boolean\n}\n\nconst DefaultDiffResult: DataProxy.DiffResult<unknown> = {\n  result: undefined,\n}\n\nconst fragmentToQueryDocMemo = new Map<DocumentNode, DocumentNode>()\nfunction getQueryDocForFragment(\n  fragmentDoc: DocumentNode,\n  fragmentName: string\n) {\n  let queryDoc = fragmentToQueryDocMemo.get(fragmentDoc)\n\n  if (!queryDoc) {\n    queryDoc = getFragmentQueryDocument(fragmentDoc, fragmentName)\n    fragmentToQueryDocMemo.set(fragmentDoc, queryDoc)\n  }\n\n  return queryDoc\n}\n\nexport const atomOfFragment = <Data extends StoreObject>(\n  getArgs: (get: Getter) => WatchFragmentArgs<Data>\n): Atom<DataProxy.DiffResult<Data>> => {\n  const loadableClientAtom = loadable(clientAtom)\n\n  const wrapperAtom = atom((get) => {\n    const loadableClient = get(loadableClientAtom)\n\n    if (loadableClient.state !== 'hasData') {\n      return null\n    }\n\n    const client = loadableClient.data\n\n    const sourceAtom = atomWithObservable(\n      (get) => {\n        const { fragment, fragmentName, from, optimistic } = getArgs(get)\n\n        // Resetting on store-version change\n        get(storeVersionAtom(client))\n\n        const id =\n          typeof from === 'string' || !from ? from : client.cache.identify(from)\n\n        return {\n          subscribe(observer: Observer<DataProxy.DiffResult<Data>>) {\n            const unsubscribe = client.cache.watch<Data>({\n              query: getQueryDocForFragment(fragment, fragmentName),\n              id,\n              callback: () => {\n                const latestData = client.readFragment<Data>(\n                  {\n                    fragment,\n                    fragmentName,\n                    id,\n                  },\n                  optimistic\n                )\n\n                if (latestData) {\n                  observer.next({ complete: true, result: latestData })\n                } else {\n                  observer.next({ complete: false })\n                }\n              },\n              optimistic,\n              returnPartialData: true,\n              immediate: true,\n            })\n\n            return {\n              unsubscribe,\n            }\n          },\n        }\n      },\n      { initialValue: DefaultDiffResult as DataProxy.DiffResult<Data> }\n    )\n\n    return sourceAtom\n  })\n\n  return atom((get) => {\n    const sourceAtom = get(wrapperAtom)\n\n    if (sourceAtom) {\n      return get(sourceAtom)\n    }\n\n    return DefaultDiffResult as DataProxy.DiffResult<Data>\n  })\n}\n"],
  "mappings": "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",
  "names": []
}
